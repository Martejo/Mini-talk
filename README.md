<h1 align="center">Client-Server Communication Project with UNIX Signals</h1>
<h2 align="center">mini-talk</h2>

<h3>Objectif</h3>
The project consists in developing a client-server communication application using exclusively UNIX signals for data exchange.  

The server must be able to receive and display character strings transmitted by the client.
<details>
  <summary>Key features</summary>

1. **Server and client**: Two distinct executables, named server and client.

2. **PID display**: The server displays its PID after launch.

3. **Data transmission**:
   
   -  The client sends a character string to the server using its PID. 
   - The server displays the string once it has been received in full.

4. **Multiple client management**: The server can receive data from several clients consecutively without restarting.

5. **Display speed**: The server must display strings quickly (e.g.: less than one second for 100 characters)

6. **Use of UNIX signals**: Communication is based on SIGUSR1 and SIGUSR2 signals.
</details>
<details>
  <summary>Bonus (Optional)</summary>

  **Acknowledgement of receipt**: The server sends a signal to the client to confirm receipt of the message.  
  **Unicode support**: Ability to handle Unicode characters.
</details>

<details>
  <summary>What are UNIX signals?</summary>  
  UNIX signals are a fundamental aspect of UNIX-like operating systems, including Linux, and serve as a method of communication between processes.

  <h3>Definition</h3>

**UNIX signals**:  
These are notifications sent to a process to let it know that a specific event has occurred.  
They are used to interrupt a process, to ask it to terminate, or to notify it of other system events.  
These are symbolic constants represented internally by numerical values, usually integers.  
Each signal in a UNIX system has an associated number that represents it.  
These numbers are used by the operating system to identify different types of signal.

**For exemple**:
 - SIGKILL is often represented by the number 9.
 - SIGTERM is often number 15.
 - SIGINT is usually number 2.

These numbers are defined in system headers, such as <signal.h> in C.  
However, in programming and everyday use, signals are generally referred to by their symbolic names (such as SIGKILL, SIGTERM, etc.) rather than by their numbers.  
This makes the code more readable and less platform-dependent, as the exact numbers can vary between different implementations of UNIX systems.

When sending or handling signals in a program, these symbolic names are used, and the operating system translates these names into their corresponding numbers for internal processing.

<h3>Basic Functionaly</h3>  

**Sending Signals**:  
Signals can be sent by the operating system, by another process, or by the process itself.  

**Receiving signals**:  
When a process receives a signal, it can either take a predefined action, or define its own handler to respond to the signal.  

<h3>Signal types</h3>

**Standard signals**:  
For example, SIGKILL to force a process to terminate, SIGTERM to request the end of a process, SIGINT generated by the Ctrl+C shortcut, and SIGSTOP to temporarily stop a process.  

**Specific signals**:  
SIGUSR1 and SIGUSR2 are user signals that can be used for customized communications between processes.

<h3>Signal handling</h3>

**Signal handlers**:
Processes can define their own signal handlers to execute specific code in response to a signal.  

**Default actions**:  
Without custom handlers, signals have default actions, such as terminate, ignore or suspend.  A bit like the windows task manager.

<h3>Asynchronous behavior</h3>

**Asynchronous nature**:  
Signals are asynchronous, meaning they can interrupt a process at any time to execute the signal handler's code.

<h3>Limitations and considerations</h3>

**Reliability**:  
Some signals may be lost if the system is overloaded, and there is generally no signal queue.  

**Safety and robustness**:  
Programming with signals requires special care to avoid race conditions and other problems associated with asynchronism.
</details>
<details>
  <summary>Functions used for mini-talk</summary>  
  
`Signal`:  
Used to define a signal handler for a specific signal.  
Usage: `signal(int signum, sighandler_t handler)`.  
Purpose: Allows the program to specify how a process should react to a particular signal  
(for example, ignore the signal, intercept it, or execute a specific function).  

`sigemptyset`:  
Function: Initializes and clears a set of signals.  
Usage: `sigemptyset(sigset_t *set)`.  
Purpose: Prepares a signal set for adding specific signals, generally used in sigaction configuration.  

`sigaddset`:  
Function: Adds a specific signal to a set of signals.  
Usage: `sigaddset(sigset_t *set, int signum)`.  
Purpose: Used to construct a set of signals to be blocked, ignored or captured.  

`sigaction`:  
Function: Examines or modifies the action associated with a specific signal.  
Usage: `sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)`.  
Purpose: Provides more precise control over signal behavior than with signal, allowing other signals to be blocked while the handler is running. 

`kill`:  
Function: Sends a signal to a process or group of processes.  
Usage: `kill(pid_t pid, int sig)`.  
Purpose: Used to send any signal to any process, usually to terminate or interrupt a process.  

`getpid`:  
Function: Returns the identifier of the calling process.  
Usage: `pid_t getpid(void)`.  
Purpose: Often used in programs where processes need to know their own PID.  

`pause`:  
Function: Suspends a process until a signal is received.  
Usage: `int pause(void)`.  
Purpose: Used in programs that wait for a signal before continuing.  

`sleep`:  
Function: suspends execution of calling program for a specified time in seconds.  
Usage: `unsigned int sleep(unsigned int seconds)`.  
Purpose: Used to pause program execution. 

`usleep`:  
Function: Suspends execution of the calling program for a specified time in microseconds.  
Usage: `int usleep(useconds_t usec)`.  
Purpose: Provides a high-precision pause method for shorter delays than those allowed by sleep.  
</details>
<details>
  <summary>The difference between signal and sigaction</summary>

The difference between signal and sigaction functions in UNIX environments is essential to understand for effective signal management.  
Here's a summary of the key differences:  

<h4>signal:</h4>

Simplicity:  
signal is simpler to use than sigaction. It is often used for basic signal handlers.  

Portability:  
Although widely suported, the signal function may behave slightly differently on different UNIX systems.  

How it works:  
When a signal is received, the specified handler is called. However, the signal's default behavior is usually restored after the handler has been invoked.  

Limitations:  
Does not allow other signals to be blocked during handler execution, which can lead to race situations.

<h4>sigaction:</h4>  

Advanced control:  
sigaction offers more precise control over signal behavior. It is recommended for more complex needs.  

Consistent behavior:  
Sigaction's behavior is well defined and consistent across different UNIX systems.  

Advanced options:  
Allows you to specify signals to be blocked during signal handler execution.  
Select whether signals should be automatically reset to their default behavior.  

Reliability: More reliable for applications requiring robust signal management, especially to avoid conditions. 

<h4>Comparison and Choice:</h4>  
Choice of approach:  
for simple needs, signal may suffice, but for applications requiring more sophisticated signal management, sigaction is preferable.  

<h4>Compatibility and safety:</h4>

sigaction is generally considered a safer and more robust approach, thanks to its predictability and ability to handle complex signal interactions.  
In summary, while signal is useful for simple, portable scenarios, sigaction is the recommended choice for more robust, accurate and reliable signal management in UNIX applications.  

***For my part, I decided to use sigaction to guarantee lossless and rapid processing of all signals.***

</details>
